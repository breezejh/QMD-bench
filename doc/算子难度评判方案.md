# 算子难度评判方案

## 维度1. 指令集差异程度

本维度旨在为 OpenCV 算子从 ARM NEON 架构到 RISC-V RVV 架构的迁移工作，提供一个清晰、可量化的**指令集差异程度**评估标准。

评判的核心依据是分析算子实现中所使用的 ARM NEON Intrinsics，并根据我们整理的《ARM Neon intrinsics v.s. RVV intrinsics》对比文档，评估其迁移到 RVV 的难度。


### 2. 难度等级定义

#### Level 1：低难度 (直接映射)
功能重叠的算子 (可以直接或概念上直接迁移)
这部分算子在两种架构中都有直接或非常相似的功能对应，是跨架构迁移时最容易处理的部分。

---

#### Level 2：高难度 (组合模拟)
 ARM NEON 独特或惯用的算子
这部分算子在RVV中没有直接的单指令对应，迁移时通常需要用多条RVV指令组合模拟，或者需要重新设计算法。

## 维度2.依赖链需迁移程度
重新审视现在的问题：
  - 所有代码都有显式/隐式依赖和长/短依赖，而且经统计发现opencv arm下各算子的依赖项规模较小(1-5个头文件)，对于Agent、LLM来说，不是什么大问题。
  - 所以体现不出我们的亮点
---
那么在针对不同架构进行算子迁移的任务中，这些依赖项有什么与众不同的地方呢<br>
最关键的点是：**依赖本身是否需要迁移**，因为普通的软件重构任务中，这些依赖链多多少少都是能用的，不需要大面积重写，是代码组织形式上的改写，而我们的迁移任务中，有绑定架构的依赖链，是无法直接使用的，必须针对特定架构进行重写，是代码内容根本上的改写。

那么我们根据算子依赖的统计情况，有如下判断依赖本身是否需要迁移的方案：
1. **识别架构绑定的模块**：
- 通过分析依赖头文件的实现内容和头文件的特性[大家一起用]，我们将它们分为两类，根据**是否深度依赖特定架构的指令实现**
	 - 架构无关模块：common.hpp[基础工具模块]，模块内的函数在任何架构上都可以直接复用
	- 架构绑定模块：saturate_cast.hpp与remap.hpp部分绑定，intrinsics.hpp、vround_helper.hpp、vtransform.hpp、separable_filter.hpp深度绑定

2.**对依赖链进行分类**
- **架构无关类的依赖链**：**算子的所有依赖（显式+隐式）都是架构无关的**，迁移成本是固定的、一次性的，一旦迁移完成，所有依赖它的算子都可以直接使用。迁移这类算子重点在关注算子本身，**无需协调迁移策略**。
	- 该类算子对于agent来说，迁移的难度**主要体现在正确替换算子内的NEON intrinsic（这由另一个硬件调用维度评估）**。
- **架构相关类的依赖链**：**算子的依赖链，无论是显示或隐式依赖，至少有一个是架构相关的**，迁移这类算子不仅要关注算子本身，还要如何整体迁移依赖链，因为这些模块被多个算子共用，**需要协调迁移策略**[如：统一接口设计，不断增加、优化分发层的配置，是否已存在针对某架构迁移的接口，这都需要在迁移各个算子时，逐渐完成迁移]。
	- 这类算字对于agent来说，迁移的难度在于**不仅需要正确迁移算子本身，还需协调迁移依赖链**。
 
---
## 两个维度如何分别评估Agent 的能力
|维度	|评估内容|测试的Agent能力|
|---|---|---|
|依赖链需迁移程度	|要迁移多少内容|• 依赖发现能力（能否找到隐式依赖）<br>• 依赖判断：能否区分架构无关 vs 架构绑定模块<br>• 上下文管理能力（读取多少文件）<br>• 模块协调能力（如何处理共用模块）|
|指令集差异程度	|怎么进行迁移|• 指令理解能力（是否知道vtbl的语义）<br>• 架构知识（是否知道RVV的对应指令）<br>• 算法设计能力（能否设计等价实现）|

----
## 最终难度分级
||依赖架构无关|依赖架构相关|
|---|---|---|
|**指令直接映射**|直接映射+迁移算子|直接映射+迁移算子和依赖链|
|**指令组合重构**|组合重构+迁移算子|组合重构+迁移算子和依赖链|
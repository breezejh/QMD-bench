{"operator_name":"median_filter","id":1,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H1","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/median_filter.cpp","operator_description":"Apply a 3x3 median filter to the image, replacing each pixel value with the median of its neighborhood, effectively reducing image noise","correctness_test_commands":["./opencv_test_imgproc --gtest_filter=OCL_ImageProc/MedianFilter.*","./opencv_test_imgproc --gtest_filter=Imgproc_MedianBlur.*"],"performance_test_commands":["./opencv_perf_imgproc --gtest_filter=OCL_MedianBlurFixture_Bilateral.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_kSize_medianBlur.*"]}
{"operator_name":"morph","id":2,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/morph.cpp","operator_description":"Perform morphological operations with 3x3 or custom kernels, including erosion (shrinking bright regions) and dilation (expanding bright regions), used for processing binary or grayscale images","correctness_test_commands":["./opencv_test_imgproc --gtest_filter=OCL_Filter/MorphFilter3x3_cols16_rows2.*","./opencv_test_imgproc --gtest_filter=OCL_Filter/MorphologyEx.*","./opencv_test_imgproc --gtest_filter=Imgproc_Morphology.*","./opencv_test_imgproc --gtest_filter=Imgproc_MorphEx.*"],"performance_test_commands":["./opencv_perf_imgproc --gtest_filter=OCL_MorphologyExFixture_MorphologyEx.*"]}
{"operator_name":"sobel","id":3,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/sobel.cpp","operator_description":"Calculate the first-order spatial derivative of an image in horizontal or vertical direction using a 3x3 Sobel kernel, used for edge detection and highlighting edge features","correctness_test_commands":["./opencv_test_imgproc --gtest_filter=Imgproc_Sobel*","./opencv_test_imgproc --gtest_filter=OCL_Filter/SobelTest.*","./opencv_test_imgproc --gtest_filter=OCL_Filter/Sobel3x3_cols16_rows2.*"],"performance_test_commands":["./opencv_perf_imgproc --gtest_filter=OCL_SobelFixture_Sobel.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_dx_dy_Border3x3_sobelFilter.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_dx_dy_Border3x3ROI_sobelFilter.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_dx_dy_Border5x5_sobelFilter.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_dx_dy_Border5x5ROI_sobelFilter.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_dx_dy_Border3x3_scharrViaSobelFilter.*"]}
{"operator_name":"fast","id":4,"library":"opencv","module":"Imgproc","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/fast.cpp","operator_description":"Rapidly detect corner features in 8-bit grayscale images using the FAST (Features from Accelerated Segment Test) algorithm","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"integral","id":5,"library":"opencv","module":"Imgproc","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/integral.cpp","operator_description":"Calculate integral image (summed area table), where each pixel stores the sum of all pixels to its upper left, and can also calculate squared integral image","correctness_test_commands":["./opencv_test_imgproc --gtest_filter=Imgproc_Integral.*","./opencv_test_imgproc --gtest_filter=OCL_Imgproc/Integral.*"],"performance_test_commands":["./opencv_perf_imgproc --gtest_filter=OCL_IntegralFixture_Integral1.*","./opencv_perf_imgproc --gtest_filter=OCL_IntegralFixture_Integral2.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_OutMatDepth_integral.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_OutMatDepth_integral_sqsum.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_OutMatDepth_integral_sqsum_tilted.*"]}
{"operator_name":"norm","id":6,"library":"opencv","module":"core","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/norm.cpp","operator_description":"Calculate L1, L2, or infinity norm of input array or difference of two arrays, providing a measure of vector or matrix size","correctness_test_commands":["./opencv_test_core --gtest_filter=OCL_Arithm/Norm.*","./opencv_test_core --gtest_filter=OCL_Arithm/Normalize.*","./opencv_test_core --gtest_filter=Core_Norm/ElemWiseTest.*"],"performance_test_commands":["./opencv_perf_core --gtest_filter=Size_MatType_NormType_norm.*"," ./opencv_perf_core --gtest_filter=Size_MatType_NormType_norm_mask.*","./opencv_perf_core --gtest_filter=Size_MatType_NormType_norm2.*","./opencv_perf_core --gtest_filter=Size_MatType_NormType_norm2_mask.*","./opencv_perf_core --gtest_filter=PerfHamming_norm.*","./opencv_perf_core --gtest_filter=Size_MatType_NormType_normalize.*","./opencv_perf_core --gtest_filter=Size_MatType_NormType_normalize_32f.*","./opencv_perf_core --gtest_filter=Size_MatType_NormType_normalize_mask.*","./opencv_perf_core --gtest_filter=OCL_NormFixture_Norm1Arg.*","./opencv_perf_core --gtest_filter=OCL_NormFixture_NormRel.*","./opencv_perf_core --gtest_filter=OCL_NormalizeFixture_Normalize.*","./opencv_perf_core --gtest_filter=OCL_NormalizeFixture_NormalizeWithMask.*"]}
{"operator_name":"threshold","id":7,"library":"opencv","module":"Imgproc","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/threshold.cpp","operator_description":"Perform various thresholding operations on images, including binary, binary inverted, truncate, to zero, and to zero inverted thresholding modes","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"pyramid","id":8,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/pyramid.cpp","operator_description":"Perform image downsampling (PyrDown) or upsampling (PyrUp) operations using Gaussian pyramid filters, commonly used for multi-resolution image analysis","correctness_test_commands":["./opencv_test_imgproc --gtest_filter=Imgproc_Pyrdown.*","./opencv_test_imgproc --gtest_filter=OCL_ImgprocPyr/PyrDown.*","./opencv_test_imgproc --gtest_filter=Imgproc_PyrUp.*","./opencv_test_imgproc --gtest_filter=OCL_ImgprocPyr/PyrUp*","./opencv_test_imgproc --gtest_filter=OCL_ImgprocPyr/PyrUp_cols2.*"],"performance_test_commands":["./opencv_perf_imgproc --gtest_filter=Size_MatType_pyrDown.*","./opencv_perf_imgproc --gtest_filter=OCL_PyrDownFixture_PyrDown.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_pyrUp.*"]}
{"operator_name":"scharr","id":9,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/scharr.cpp","operator_description":"Calculate the first-order derivative of an image in horizontal or vertical direction using a 3x3 Scharr kernel, more sensitive to diagonal edges than Sobel, providing more accurate gradient estimation","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"template_matching","id":10,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/template_matching.cpp","operator_description":"Perform template matching operation, searching and locating the region in the image most similar to the given template","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"sum","id":11,"library":"opencv","module":"core","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/sum.cpp","operator_description":"Calculate the sum or squared sum of all elements in the input array, supporting multi-channel data","correctness_test_commands":["./opencv_test_core --gtest_filter=OCL_Arithm/Sum.*","./opencv_test_core --gtest_filter=Core_Sum/ElemWiseTest.*"],"performance_test_commands":["./opencv_perf_core --gtest_filter=Size_MatType_sum.*","./opencv_perf_core --gtest_filter=OCL_SumFixture_Sum.*"]}
{"operator_name":"fill_minmaxloc","id":12,"library":"opencv","module":"core","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/fill_minmaxloc.cpp","operator_description":"Find the global minimum and maximum values in an array, and record the coordinates of all positions where minimum and maximum values occur","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"meanstddev","id":13,"library":"opencv","module":"core","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/meanstddev.cpp","operator_description":"Calculate the mean and standard deviation of array elements, providing statistical information about data distribution","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"count_nonzero","id":14,"library":"opencv","module":"core","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/count_nonzero.cpp","operator_description":"Count the total number of non-zero elements in the input array","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"dot_product","id":15,"library":"opencv","module":"core","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/dot_product.cpp","operator_description":"Calculate the dot product (scalar product) of two input arrays, multiplying corresponding elements and summing","correctness_test_commands":["./opencv_test_core --gtest_filter=Core_DotProduct.*","./opencv_test_core --gtest_filter=OCL_Arithm/UMatDot.*"],"performance_test_commands":["./opencv_perf_core --gtest_filter=MatType_Length_dot.*","./opencv_perf_core --gtest_filter=OCL_UMatDotFixture_UMatDot.*"]}
{"operator_name":"reduce","id":16,"library":"opencv","module":"core","dependency_chain_complexity":"D1","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/reduce.cpp","operator_description":"Perform column-wise reduction operations on images or matrices, calculating the sum, minimum, or maximum of each column","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"separable_filter","id":17,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H1","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/separable_filter.cpp","operator_description":"Apply a 3x3 separable filter to images, decomposing 2D convolution into 1D horizontal and vertical convolutions to improve computational efficiency","correctness_test_commands":["./opencv_test_imgproc --gtest_filter=OCL_ImageProc/SepFilter2D.*"],"performance_test_commands":["./opencv_perf_imgproc --gtest_filter=OCL_SepFilter2D.*"]}
{"operator_name":"absdiff","id":18,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H1","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/absdiff.cpp","operator_description":"Calculate the absolute difference between corresponding elements of two input arrays","correctness_test_commands":["./opencv_test_core --gtest_filter=OCL_Arithm/Absdiff.*","./opencv_test_core --gtest_filter=Core_AbsDiff/ElemWiseTest.*","./opencv_test_core --gtest_filter=Core_AbsDiffS/ElemWiseTest.*"],"performance_test_commands":["./opencv_perf_core --gtest_filter=OCL_AbsDiffFixture_Absdiff.*","./opencv_perf_core --gtest_filter=BinaryOpTest.absdiff*"]}
{"operator_name":"bitwise","id":19,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H1","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/bitwise.cpp","operator_description":"Perform element-wise bitwise operations (AND, OR, XOR, NOT), performing bitwise logical operations on two input arrays or array and scalar","correctness_test_commands":["./opencv_test_core --gtest_filter=OCL_Arithm/Bitwise_and.*","./opencv_test_core --gtest_filter=OCL_Arithm/Bitwise_or.*","./opencv_test_core --gtest_filter=OCL_Arithm/Bitwise_xor.*","./opencv_test_core --gtest_filter=OCL_Arithm/Bitwise_not.*"],"performance_test_commands":["./opencv_perf_core --gtest_filter=OCL_BitwiseAndFixture_Bitwise_and.*","./opencv_perf_core --gtest_filter=Size_MatType_bitwise_and.*","./opencv_perf_core --gtest_filter=OCL_BitwiseOrFixture_Bitwise_or.*","./opencv_perf_core --gtest_filter=Size_MatType_bitwise_or.*","./opencv_perf_core --gtest_filter=OCL_BitwiseXorFixture_Bitwise_xor.*","./opencv_perf_core --gtest_filter=Size_MatType_bitwise_xor.*","./opencv_perf_core --gtest_filter=OCL_BitwiseNotFixture_Bitwise_not.*"]}
{"operator_name":"min_max","id":20,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H1","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/min_max.cpp","operator_description":"Calculate element-wise minimum or maximum of two input arrays or array and scalar, supporting multiple data types","correctness_test_commands":["./opencv_test_core --gtest_filter=OCL_Arithm/Max.*","./opencv_test_core --gtest_filter=Core_Max/ElemWiseTest.*","./opencv_test_core --gtest_filter=Core_MaxS/ElemWiseTest.*","./opencv_test_core --gtest_filter=OCL_Arithm/Min.*","./opencv_test_core --gtest_filter=Core_Min/ElemWiseTest.*","./opencv_test_core --gtest_filter=Core_MinS/ElemWiseTest.*"],"performance_test_commands":["./opencv_perf_core --gtest_filter=OCL_MaxFixture_Max.*","./opencv_perf_core --gtest_filter=BinaryOpTest.max*","./opencv_perf_core --gtest_filter=OCL_MinFixture_Min.*","./opencv_perf_core --gtest_filter=BinaryOpTest.min*"]}
{"operator_name":"blur","id":21,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/blur.cpp","operator_description":"Apply 3x3 or 5x5 box filter to images for blurring, achieving smoothing effect by averaging pixel values in the kernel region","correctness_test_commands":["./opencv_test_imgproc --gtest_filter=OCL_ImageProc/BoxFilter.*","./opencv_test_imgproc --gtest_filter=OCL_ImageProc/BoxFilter3x3_cols16_rows2.*"],"performance_test_commands":["./opencv_perf_imgproc --gtest_filter=OCL_MedianBlurFixture_Bilateral.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_kSize_medianBlur.*","./opencv_perf_imgproc --gtest_filter=OCL_BlurFixture_Blur.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_BorderType3x3_blur3x3.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_BorderType_blur16x16.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_BorderType_blur5x5.*"]}
{"operator_name":"accumulate","id":22,"library":"opencv","module":"Imgproc","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/accumulate.cpp","operator_description":"Accumulate input array to target array, supporting three modes: simple accumulation, squared accumulation, and weighted accumulation","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"add","id":23,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/add.cpp","operator_description":"Perform element-wise addition of two arrays, supporting saturation or wrap-around overflow handling strategies","correctness_test_commands":["./opencv_test_core --gtest_filter=OCL_Arithm/Add.*","./opencv_test_core --gtest_filter=Core_Add/ElemWiseTest.*","./opencv_test_core --gtest_filter=Core_AddS/ElemWiseTest.*"],"performance_test_commands":["./opencv_perf_core --gtest_filter=OCL_AddFixture_Add.*","./opencv_perf_core --gtest_filter=BinaryOpTest.add*","./opencv_perf_core --gtest_filter=ArithmMixedTest.add*"]}
{"operator_name":"add_weighted","id":24,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/add_weighted.cpp","operator_description":"Calculate weighted sum of two input arrays: dst = alpha*src1 + beta*src2 + gamma, used for image fusion and brightness adjustment","correctness_test_commands":["./opencv_test_core --gtest_filter=OCL_Arithm/ScaleAdd.*","./opencv_test_core --gtest_filter=Core_ScaleAdd/ElemWiseTest.*","./opencv_test_core --gtest_filter=OCL_Arithm/AddWeighted.*","./opencv_test_core --gtest_filter=Core_AddWeighted/ElemWiseTest.*"],"performance_test_commands":["./opencv_perf_core --gtest_filter=OCL_AddWeightedFixture_AddWeighted.*","./opencv_perf_core --gtest_filter=Size_MatType_addWeighted.*"]}
{"operator_name":"cmp","id":25,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/cmp.cpp","operator_description":"Perform element-wise comparison operations (equal, not equal, greater than, greater than or equal) on two arrays, outputting binary mask representing comparison results","correctness_test_commands":["./opencv_test_core --gtest_filter=OCL_Arithm/Compare.*","./opencv_test_core --gtest_filter=Core_Cmp/ElemWiseTest.*"],"performance_test_commands":["./opencv_perf_core --gtest_filter=OCL_CompareFixture_Compare.*","./opencv_perf_core --gtest_filter=OCL_CompareFixture_CompareScalar.*","./opencv_perf_core --gtest_filter=Size_MatType_CmpType_compare.*","./opencv_perf_core --gtest_filter=Size_MatType_CmpType_compareScalar.*"]}
{"operator_name":"convert_depth","id":26,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/aconvert_depth.cpp","operator_description":"Convert data type (depth) of image elements, optionally applying left or right bit shift operations","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"flip","id":27,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/flip.cpp","operator_description":"Perform image flip operations, supporting horizontal flip, vertical flip, or both horizontal and vertical flips simultaneously","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"laplacian","id":28,"library":"opencv","module":"Imgproc","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/laplacian.cpp","operator_description":"Apply Laplacian filter (supporting 3x3, 1-channel, 3-channel, 5-channel configurations) to highlight regions of rapid intensity changes in images, i.e., edges","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"magnitude","id":29,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/magnitude.cpp","operator_description":"Calculate magnitude of 2D vectors (such as image gradients), computing element-wise magnitude of x and y components through square root of sum of squares","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"minmaxloc","id":30,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/minmaxloc.cpp","operator_description":"Find global minimum and maximum values in an array, and record coordinates of all positions where minimum and maximum values occur, optionally using a mask","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"mul","id":31,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/mul.cpp","operator_description":"Perform element-wise multiplication of two arrays and apply scaling factor, supporting saturation or wrap-around overflow handling strategies","correctness_test_commands":["./opencv_test_core --gtest_filter=OCL_Arithm/Mul.*","./opencv_test_core --gtest_filter=Core_Mul/ElemWiseTest.*"],"performance_test_commands":["./opencv_perf_core --gtest_filter=OCL_MulFixture_Multiply.*","./opencv_perf_core --gtest_filter=BinaryOpTest.mul*","./opencv_perf_core --gtest_filter=ArithmMixedTest.mul*"]}
{"operator_name":"phase","id":32,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/phase.cpp","operator_description":"Calculate angle (phase) of 2D vectors, computing direction angle of each vector based on two input arrays (x and y components), commonly used for image gradient analysis","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"sub","id":33,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/sub.cpp","operator_description":"Perform element-wise subtraction of two arrays, supporting saturation or wrap-around underflow handling strategies","correctness_test_commands":["./opencv_test_core --gtest_filter=Arithm/SubtractOutputMatNotEmpty.*","./opencv_test_core --gtest_filter=Subtract.*","./opencv_test_core --gtest_filter=OCL_Arithm/Subtract.*","./opencv_test_core --gtest_filter=Arithm/SubtractOutputMatNotEmpty.*"],"performance_test_commands":["./opencv_perf_core --gtest_filter=OCL_SubtractFixture_Subtract.*","./opencv_perf_core --gtest_filter=BinaryOpTest.sub*","./opencv_perf_core --gtest_filter=ArithmMixedTest.sub*"]}
{"operator_name":"div","id":34,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/div.cpp","operator_description":"Perform element-wise division of two arrays, supporting scaling factor and saturation/wrap-around overflow handling strategies, also supporting calculation of reciprocal of array elements","correctness_test_commands":["./opencv_test_core --gtest_filter=Core_Div/ElemWiseTest.*","./opencv_test_core --gtest_filter=Core_DivideRules.*","./opencv_test_core --gtest_filter=UMat/Core_DivideRules.*","./opencv_test_core --gtest_filter=Core_Recip/ElemWiseTest.*","./opencv_test_core --gtest_filter=OCL_Arithm/Div.*","./opencv_test_core --gtest_filter=Core_RecipMixed/ArithmMixedTest.*"],"performance_test_commands":["./opencv_perf_core --gtest_filter=OCL_DivFixture_Divide.*","./opencv_perf_core --gtest_filter=BinaryOpTest.div*","./opencv_perf_core --gtest_filter=ArithmMixedTest.div*","./opencv_perf_core --gtest_filter=BinaryOpTest.recip*"]}
{"operator_name":"colorconvert","id":35,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/colorconvert.cpp","operator_description":"Perform conversions between different color spaces, supporting various color space conversion operations such as RGB to grayscale, RGB to YUV, YUV to RGB","correctness_test_commands":["./opencv_test_imgproc --gtest_filter=OCL_ImgProc/CvtColor.*","./opencv_test_imgproc --gtest_filter=OCL_ImgProc/CvtColor8u32f.*","./opencv_test_imgproc --gtest_filter=OCL_ImgProc/CvtColor8u.*","./opencv_test_imgproc --gtest_filter=OCL_ImgProc/CvtColor_YUV2RGB_420.*","./opencv_test_imgproc --gtest_filter=OCL_ImgProc/CvtColor_RGB2YUV_420.*","./opencv_test_imgproc --gtest_filter=OCL_ImgProc/CvtColor_YUV2RGB_422.*","./opencv_test_imgproc --gtest_filter=OCL_ImgProc/CvtColor_RGB2YUV_422.*","./opencv_test_imgproc --gtest_filter=cvt420/Imgproc_ColorYUV.*","./opencv_test_imgproc --gtest_filter=cvt422/Imgproc_ColorYUV.*","./opencv_test_imgproc --gtest_filter=Imgproc_cvtColor_BE.*"],"performance_test_commands":["./opencv_perf_imgproc --gtest_filter=OCL_CvtColorFixture_CvtColor.*","./opencv_perf_imgproc --gtest_filter=Size_CvtMode_cvtColor8u.*","./opencv_perf_imgproc --gtest_filter=Size_CvtMode2_cvtColorYUV420.*","./opencv_perf_imgproc --gtest_filter=Size_CvtMode3_cvtColorRGB2YUV420p.*"]}
{"operator_name":"convolution","id":36,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/convolution.cpp","operator_description":"Apply 3x3 custom convolution kernel to images for general convolution operations, supporting constant and replicate border modes","correctness_test_commands":["./opencv_test_imgproc --gtest_filter=OCL_ImageProc/Filter2D.*","./opencv_test_imgproc --gtest_filter=OCL_Filter/LaplacianTest.*","./opencv_test_imgproc --gtest_filter=OCL_Filter/Laplacian3_cols16_rows2.*"],"performance_test_commands":["./opencv_perf_imgproc --gtest_filter=TestFilter2d_Filter2d.*"]}
{"operator_name":"resize","id":37,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/resize.cpp","operator_description":"Resize images using different interpolation methods, supporting nearest neighbor (fast), area (high quality downsampling), and bilinear (smooth scaling) interpolation","correctness_test_commands":["./opencv_test_imgproc --gtest_filter=OCL_ImgprocWarp/Resize.*","./opencv_test_imgproc --gtest_filter=OCL_ImgprocWarpLinearExact/Resize.*","./opencv_test_imgproc --gtest_filter=OCL_ImgprocWarpResizeArea/Resize.*","./opencv_test_imgproc --gtest_filter=OCL_Resize.*","./opencv_test_imgproc --gtest_filter=Imgproc_ResizeExact.*","./opencv_test_imgproc --gtest_filter=Resize.*","./opencv_test_imgproc --gtest_filter=Imgproc_Resize_Test.*","./opencv_test_imgproc --gtest_filter=Resize_Bitexact.*"],"performance_test_commands":["./opencv_perf_imgproc --gtest_filter=OCL__3vs4_Fixture_Resize.*","./opencv_perf_imgproc --gtest_filter=OCL_ResizeFixture_Resize.*","./opencv_perf_imgproc --gtest_filter=OCL_ResizeAreaFixture_Resize.*","./opencv_perf_imgproc --gtest_filter=OCL_ResizeLinearExactFixture_Resize.*","./opencv_perf_imgproc --gtest_filter=MatInfo_Size_Size_resizeUpLinear.*","./opencv_perf_imgproc --gtest_filter=MatInfo_SizePair_resizeUpLinearNonExact.*","./opencv_perf_imgproc --gtest_filter=MatInfo_Size_Size_resizeDownLinear.*","./opencv_perf_imgproc --gtest_filter=MatInfo_SizePair_resizeDownLinearNonExact.*","./opencv_perf_imgproc --gtest_filter=MatInfo_Size_Scale_ResizeAreaFast.*","./opencv_perf_imgproc --gtest_filter=MatInfo_Size_Scale_Area_ResizeArea.*","./opencv_perf_imgproc --gtest_filter=MatInfo_Size_Scale_NN_ResizeNN.*","./opencv_perf_imgproc --gtest_filter=MatInfo_Size_Scale_NN_ResizeNNExact.*"]}
{"operator_name":"canny","id":38,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/canny.cpp","operator_description":"Execute Canny edge detection algorithm, extracting strong edges in images through gradient calculation, non-maximum suppression, and double threshold processing","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"channel_extract","id":39,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/channel_extract.cpp","operator_description":"Extract specified single color channel from multi-channel (2, 3, or 4 channels) images","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"channels_combine","id":40,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/channels_combine.cpp","operator_description":"Merge multiple (2, 3, or 4) single-channel images into one multi-channel image","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"convert","id":41,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/convert.cpp","operator_description":"Convert array elements between different data types, automatically performing saturation conversion to prevent overflow","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"convert_scale","id":42,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/convert_scale.cpp","operator_description":"Convert data type of array elements and apply linear transformation: dst = src*alpha + beta, used for type conversion and value scaling","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"gaussian_blur","id":43,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/gaussian_blur.cpp","operator_description":"Apply 3x3 Gaussian filter to images for smoothing, using Gaussian weighted kernel to reduce image noise and details","correctness_test_commands":["./opencv_test_imgproc --gtest_filter=Imgproc_GaussianBlur.*"],"performance_test_commands":["./opencv_perf_imgproc --gtest_filter=Size_MatType_BorderType3x3_gaussianBlur3x3.*","./opencv_perf_imgproc --gtest_filter=Size_MatType_BorderType_gaussianBlur5x5.*"]}
{"operator_name":"opticalflow","id":44,"library":"opencv","module":"video","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/opticalflow.cpp","operator_description":"Calculate sparse optical flow of image sequences using pyramid Lucas-Kanade algorithm, tracking motion trajectories of pixels in images","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"remap","id":45,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/remap.cpp","operator_description":"Remap (geometric transform) images according to pre-computed mapping tables, supporting nearest neighbor and linear interpolation","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"warp_affine","id":46,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/warp_affine.cpp","operator_description":"Apply affine transformation to images, supporting linear geometric transformation operations such as rotation, scaling, translation, and shearing","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"warp_perspective","id":47,"library":"opencv","module":"imgproc","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/warp_perspective.cpp","operator_description":"Apply perspective transformation to images, enabling more complex nonlinear geometric transformations including affine transformations, commonly used for correcting image perspective","correctness_test_commands":[],"performance_test_commands":[]}
{"operator_name":"in_range","id":48,"library":"opencv","module":"core","dependency_chain_complexity":"D2","hardware_instruction_discrepancy":"H2","source_arch":"carotene","source_code_path":"opencv/hal/carotene/src/in_range.cpp","operator_description":"Check whether each element in the array falls within the specified upper and lower boundary range, outputting binary mask representing the judgment result","correctness_test_commands":[],"performance_test_commands":[]}

{"id":1,"cpp_filename":"compareHist_Demo.cpp","library":"opencv","source_code_path":"opencv/samples/cpp/tutorial_code/Histograms_Matching/compareHist_Demo.cpp","application_description":"Histogram comparison: Convert multiple images to HSV color space and calculate histograms, compare histogram similarity using different methods, suitable for image retrieval, similarity matching, and other scenarios","default_data_path":"opencv/doc/tutorials/imgproc/histograms/histogram_comparison/images/Histogram_Comparison_Source_0.jpg（通过samples::findFile自动查找）","involved_operators":["cvtBGRtoHSV"],"corresponding_operator_interfaces":["int cvtBGRtoHSV(const uchar *src_data, size_t src_step, uchar *dst_data, size_t dst_step, int width, int height, int depth, int scn, bool swapBlue, bool isFullRange, bool isHSV);"]}
{"id":2,"cpp_filename":"dft.cpp","library":"opencv","source_code_path":"opencv/samples/cpp/dft.cpp","application_description":"Discrete Fourier Transform: Perform DFT transformation on images, calculate power spectrum and display frequency spectrum magnitude, process complex plane through split and merge operations, suitable for frequency domain analysis, image filtering, and other scenarios","default_data_path":"opencv/samples/data/lena.jpg","involved_operators":["merge32s","dftInit2D","dft2D","dftFree2D","split32s","magnitude32f"],"corresponding_operator_interfaces":["int merge32s(const int **src_data, int *dst_data, int len, int cn);","int dftInit2D(cvhalDFT **context, int width, int height, int depth, int src_channels, int dst_channels, int flags, int nonzero_rows);","int dft2D(cvhalDFT *context, const uchar *src_data, size_t src_step, uchar *dst_data, size_t dst_step);","int dftFree2D(cvhalDFT *context);","int split32s(const int *src_data, int **dst_data, int len, int cn);","int magnitude32f(const float *x, const float *y, float *dst, int len);"]}
{"id":3,"cpp_filename":"Remap_Demo.cpp","library":"opencv","source_code_path":"opencv/samples/cpp/tutorial_code/ImgTrans/Remap_Demo.cpp","application_description":"Image remapping and distortion correction: Use remap function for image geometric transformation, supporting various mapping modes such as scaling, mirroring, and flipping, suitable for lens distortion correction, fisheye camera correction, and other scenarios","default_data_path":"opencv/samples/data/chicky_512.png","involved_operators":["remap32f"],"corresponding_operator_interfaces":["int remap32f(int src_type, const uchar *src_data, size_t src_step, int src_width, int src_height, uchar *dst_data, size_t dst_step, int dst_width, int dst_height, float* mapx, size_t mapx_step, float* mapy, size_t mapy_step, int interpolation, int border_type, const double border_value[4]);"]}
{"id":4,"cpp_filename":"image_alignment.cpp","library":"opencv","source_code_path":"opencv/samples/cpp/image_alignment.cpp","application_description":"Image alignment and registration: Use ECC algorithm for image alignment, automatically calculate affine transformation matrix, suitable for image stitching, medical image registration, document correction, and other scenarios","default_data_path":"opencv/samples/data/fruits.jpg","involved_operators":["warpAffine"],"corresponding_operator_interfaces":["int warpAffine(int src_type, const uchar *src_data, size_t src_step, int src_width, int src_height, uchar *dst_data, size_t dst_step, int dst_width, int dst_height, const double M[6], int interpolation, int borderType, const double borderValue[4]);"]}
{"id":5,"cpp_filename":"Laplace_Demo.cpp","library":"opencv","source_code_path":"opencv/samples/cpp/tutorial_code/ImgTrans/Laplace_Demo.cpp","application_description":"Laplace edge detection: Use Laplacian operator for edge detection, first convert to grayscale and apply Laplace operator to extract edges, suitable for image edge extraction, feature detection, and other scenarios","default_data_path":"opencv/samples/data/lena.jpg","involved_operators":["cvtBGRtoGray"],"corresponding_operator_interfaces":["int cvtBGRtoGray(const uchar *src_data, size_t src_step, uchar *dst_data, size_t dst_step, int width, int height, int depth, int scn, bool swapBlue);"]}
{"id":6,"cpp_filename":"edge.cpp","library":"opencv","source_code_path":"opencv/samples/cpp/edge.cpp","application_description":"Edge detection: Use Canny algorithm for edge detection, simultaneously demonstrating operators such as boxFilter, canny, and Scharr, suitable for image segmentation, contour extraction, object detection, and other scenarios","default_data_path":"opencv/samples/data/fruits.jpg","involved_operators":["boxFilter","canny","scharr"],"corresponding_operator_interfaces":["int boxFilter(const uchar* src_data, size_t src_step, uchar* dst_data, size_t dst_step, int width, int height, int src_depth, int dst_depth, int cn, int margin_left, int margin_top, int margin_right, int margin_bottom, size_t ksize_width, size_t ksize_height, int anchor_x, int anchor_y, bool normalize, int border_type);","int canny(const uchar* src_data, size_t src_step, uchar* dst_data, size_t dst_step, int width, int height, int cn, double lowThreshold, double highThreshold, int ksize, bool L2gradient);","int scharr(const uchar* src_data, size_t src_step, uchar* dst_data, size_t dst_step, int width, int height, int src_depth, int dst_depth, int cn, int margin_left, int margin_top, int margin_right, int margin_bottom, int dx, int dy, double scale, double delta, int border_type);"]}
{"id":7,"cpp_filename":"Sobel_Demo.cpp","library":"opencv","source_code_path":"opencv/samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp","application_description":"Sobel edge detection: Use Sobel operator to calculate image gradient for edge detection, suitable for image feature extraction, object contour detection, and other scenarios","default_data_path":"opencv/samples/data/lena.jpg","involved_operators":["sobel"],"corresponding_operator_interfaces":["int sobel(const uchar* src_data, size_t src_step, uchar* dst_data, size_t dst_step, int width, int height, int src_depth, int dst_depth, int cn, int margin_left, int margin_top, int margin_right, int margin_bottom, int dx, int dy, int ksize, double scale, double delta, int border_type);"]}
{"id":8,"cpp_filename":"morphology2.cpp","library":"opencv","source_code_path":"opencv/samples/cpp/morphology2.cpp","application_description":"Morphological image processing: Demonstrate erosion, dilation, opening, and closing operations, supporting various structural elements, suitable for image denoising, object segmentation, feature extraction, and other scenarios","default_data_path":"opencv/samples/data/baboon.jpg","involved_operators":["morph"],"corresponding_operator_interfaces":["int morphInit(cvhalFilter2D **context, int operation, int src_type, int dst_type, int max_width, int max_height, int kernel_type, uchar *kernel_data, size_t kernel_step, int kernel_width, int kernel_height, int anchor_x, int anchor_y, int borderType, const double borderValue[4], int iterations, bool allowSubmatrix, bool allowInplace);","int morph(cvhalFilter2D *context, uchar *src_data, size_t src_step, uchar *dst_data, size_t dst_step, int width, int height, int src_full_width, int src_full_height, int src_roi_x, int src_roi_y, int dst_full_width, int dst_full_height, int dst_roi_x, int dst_roi_y);","int morphFree(cvhalFilter2D *context);"]}
{"id":9,"cpp_filename":"Pyramids.cpp","library":"opencv","source_code_path":"opencv/samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp","application_description":"Image pyramid scaling: Interactive demonstration of upsampling and downsampling operations of image pyramid, press 'i' to enlarge image, press 'o' to shrink image, suitable for image scaling, multi-scale analysis, and other scenarios","default_data_path":"opencv/samples/data/chicky_512.png","involved_operators":["pyrDown","pyrUp"],"corresponding_operator_interfaces":["int pyrdown(const uchar* src_data, size_t src_step, int src_width, int src_height, uchar* dst_data, size_t dst_step, int dst_width, int dst_height, int depth, int cn, int border_type);","int pyrup(const uchar* src_data, size_t src_step, int src_width, int src_height, uchar* dst_data, size_t dst_step, int dst_width, int dst_height, int depth, int cn, int border_type);"]}
{"id":10,"cpp_filename":"EqualizeHist_Demo.cpp","library":"opencv","source_code_path":"opencv/samples/cpp/tutorial_code/Histograms_Matching/EqualizeHist_Demo.cpp","application_description":"Histogram equalization: Perform histogram equalization on grayscale images to enhance image contrast, suitable for medical image enhancement, low-light image processing, and other scenarios","default_data_path":"opencv/samples/data/lena.jpg","involved_operators":["equalizeHist"],"corresponding_operator_interfaces":["int equalizeHist(const uchar* src_data, size_t src_step, uchar* dst_data, size_t dst_step, int width, int height);"]}
{"id":11,"cpp_filename":"demhist.cpp","library":"opencv","source_code_path":"opencv/samples/cpp/demhist.cpp","application_description":"Histogram statistics and analysis: Calculate and display image histogram, adjust brightness and contrast parameters in real-time, suitable for image enhancement, quality assessment, and other scenarios","default_data_path":"opencv/samples/data/baboon.jpg","involved_operators":["calcHist"],"corresponding_operator_interfaces":["int calcHist(const uchar* src_data, size_t src_step, int src_type, int src_width, int src_height, float* hist_data, int hist_size, const float** ranges, bool uniform, bool accumulate);"]}
{"id":12,"cpp_filename":"filter2D_demo.cpp","library":"opencv","source_code_path":"opencv/samples/cpp/tutorial_code/ImgTrans/filter2D_demo.cpp","application_description":"Custom linear filtering: Use filter2D function to implement custom linear filters, supporting normalized box filter kernels of different sizes, suitable for image enhancement, blur processing, and other scenarios","default_data_path":"opencv/samples/data/lena.jpg","involved_operators":["filter2D"],"corresponding_operator_interfaces":["int filterInit(cvhalFilter2D **context, uchar *kernel_data, size_t kernel_step, int kernel_type, int kernel_width, int kernel_height, int max_width, int max_height, int src_type, int dst_type, int borderType, double delta, int anchor_x, int anchor_y, bool allowSubmatrix, bool allowInplace);","int filter(cvhalFilter2D *context, uchar *src_data, size_t src_step, uchar *dst_data, size_t dst_step, int width, int height, int full_width, int full_height, int offset_x, int offset_y);","int filterFree(cvhalFilter2D *context);"]}
{"id":13,"cpp_filename":"Threshold.cpp","library":"opencv","source_code_path":"opencv/samples/cpp/tutorial_code/ImgProc/Threshold.cpp","application_description":"Image thresholding: Demonstrate fixed thresholding methods, supporting various threshold types, suitable for image binarization, object segmentation, and other scenarios","default_data_path":"opencv/samples/data/stuff.jpg","involved_operators":["threshold"],"corresponding_operator_interfaces":["int threshold(const uchar* src_data, size_t src_step, uchar* dst_data, size_t dst_step, int width, int height, int depth, int cn, double thresh, double maxValue, int thresholdType);"]}
{"id":14,"cpp_filename":"Morphology_3.cpp","library":"opencv","source_code_path":"opencv/samples/cpp/tutorial_code/ImgProc/morph_lines_detection/Morphology_3.cpp","application_description":"Morphological line detection: Use morphological operations and adaptive thresholding to extract horizontal and vertical lines in images, suitable for document image processing, table recognition, and other scenarios","default_data_path":"opencv/samples/data/notes.png","involved_operators":["adaptiveThreshold"],"corresponding_operator_interfaces":["int adaptiveThreshold(const uchar* src_data, size_t src_step, uchar* dst_data, size_t dst_step, int width, int height, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C);"]}